### 分布式 sing-box 管理平台架构设计（基于 Karmada-Manager & frp 最佳实践）

---

#### **一、核心目标**  
在 **1C1G 低配置节点** 环境下，实现 **轻量级、高可用** 的 sing-box 分布式管理平台，核心功能包括：节点配置 CRU（增删改查）、节点监控（CPU/内存/磁盘/网络 IO）、用户流量与套餐管理、Clash API 数据集成。架构采用 **B/S（前端）+ C/S（后端服务）** 混合模式，通过 **SkyWalking 统一无侵入集成** 实现全链路监控，日志使用 **Zap** 结构化输出，降低资源占用。

---

### **二、整体架构概览**  
```mermaid
graph TD
    subgraph 前端层
        Frontend[用户浏览器] -->|HTTP| WebServer[sing-box-web]
    end

    subgraph 应用层
        WebServer -->|gRPC| APIserver[sing-box-api]
        APIserver -->|gRPC| Agent1[sing-box-agent@节点1]
        APIserver -->|gRPC| Agent2[sing-box-agent@节点2]
        APIserver -->|gRPC| AgentN[sing-box-agent@节点N]
    end

    subgraph 数据层
        MySQL[用户/套餐/流量/日志/配置元数据] <--> WebServer
        MinIO[配置文件存储] <--> Agent1 & Agent2 & AgentN
    end

    subgraph 监控观测层
        SkyWalkingCollector[SkyWalking 采集器] <--|HTTP/gRPC| WebServer & APIserver & Agent1 & Agent2 & AgentN
        SkyWalkingUI[SkyWalking UI] <--|数据| SkyWalkingCollector
        Filebeat[日志收集] <--|文件| WebServer & APIserver & Agent1 & Agent2 & AgentN --> Elasticsearch[日志存储]
    end
```

---

### **三、项目结构设计（参考 Karmada-Manager & frp 最佳实践）**

#### **1. 整体项目布局**
```
sing-box-platform/
├── cmd/                           # 应用程序入口点
│   ├── web/                       # Web 服务器
│   │   └── main.go
│   ├── api/                       # API 服务器  
│   │   ├── main.go
│   │   └── app/
│   │       ├── options/           # 命令行选项
│   │       ├── routes/            # 路由注册
│   │       └── server.go          # 服务器核心逻辑
│   └── agent/                     # 节点代理
│       ├── main.go
│       └── app/
│           ├── options/
│           └── agent.go
├── pkg/                           # 可复用包
│   ├── config/                    # 配置管理（版本化）
│   │   ├── v1/                    # 配置版本 v1
│   │   │   ├── web.go
│   │   │   ├── api.go
│   │   │   └── agent.go
│   │   └── validation/            # 配置验证
│   ├── client/                    # 客户端管理
│   │   ├── manager.go             # 客户端管理器
│   │   └── grpc/                  # gRPC 客户端
│   ├── server/                    # 服务端组件
│   │   ├── web/                   # Web 服务器
│   │   ├── api/                   # API 服务器
│   │   └── agent/                 # Agent 服务器
│   ├── models/                    # 数据模型
│   ├── metrics/                   # 监控指标
│   ├── auth/                      # 认证授权
│   ├── util/                      # 工具函数
│   └── version/                   # 版本信息
├── api/                           # API 定义（Protobuf）
│   └── v1/
│       ├── agent.proto
│       └── management.proto
├── web/                           # 前端代码
│   ├── src/
│   ├── dist/
│   └── package.json
├── deploy/                        # 部署文件
├── docs/                          # 文档
├── hack/                          # 工具脚本
├── Makefile
├── go.mod
└── go.sum
```

#### **2. 核心模块设计（轻量化适配）**  

##### **A. sing-box-web（Web 后端）**  
- **功能**：用户认证（JWT）、权限控制（RBAC）、套餐与订阅管理、流量统计与状态管理（定时任务）、操作日志记录（Zap）、请求转发至 `sing-box-api`。  
- **技术栈**：Go 1.23 + Gin（低内存 Web 框架）+ GORM（轻量 ORM）+ Zap（高性能结构化日志）+ SkyWalking Go Agent（无侵入）。

```go
// cmd/web/app/server.go
type WebServer struct {
    Config   *v1.WebConfig
    Engine   *gin.Engine
    Database *gorm.DB
    Logger   *zap.Logger
    Metrics  metrics.Interface
}

func (s *WebServer) Run(ctx context.Context) error {
    // 启动 HTTP 服务器
    // 注册路由
    // 启动健康检查
    // 监听关闭信号
}
```

##### **B. sing-box-api（RPC 协调器）**  
- **功能**：节点操作协调（配置下发、服务重启）、接收 Agent 上报的用户流量数据、执行用户启用/禁用/移除指令、Clash API 数据聚合。
- **技术栈**：Go 1.23 + gRPC（轻量 RPC 框架）+ Zap（高性能结构化日志）+ SkyWalking Go Agent（无侵入）。  

```go
// cmd/api/app/server.go
type APIServer struct {
    Config      *v1.APIConfig
    GRPCServer  *grpc.Server
    ClientMgr   client.Manager
    Logger      *zap.Logger
    Metrics     metrics.Interface
}

func (s *APIServer) Run(ctx context.Context) error {
    // 启动 gRPC 服务器
    // 注册服务处理器
    // 启动客户端管理器
    // 监听关闭信号
}
```

##### **C. sing-box-agent（节点代理）**  
- **功能**：部署在 1C1G 节点上，执行配置下发、服务管理、监控数据采集、流量上报、用户管理指令执行。
- **技术栈**：Go 1.23（静态编译）+ Cobra（CLI）+ Prometheus Client + Zap（高性能结构化日志）+ SkyWalking Go Agent。

```go
// cmd/agent/app/agent.go
type Agent struct {
    Config      *v1.AgentConfig
    GRPCClient  client.AgentClient
    Monitor     monitor.Interface
    Logger      *zap.Logger
    Cancel      context.CancelFunc
}

func (a *Agent) Run(ctx context.Context) error {
    // 连接到 API 服务器
    // 启动监控采集
    // 启动配置同步
    // 监听关闭信号
}
```

---

### **四、配置管理设计（参考 frp v1 配置架构）**

#### **1. 版本化配置结构**
```go
// pkg/config/v1/common.go
type APIMetadata struct {
    APIVersion string `json:"apiVersion,omitempty"`
    Kind       string `json:"kind,omitempty"`
}

// pkg/config/v1/web.go
type WebConfig struct {
    APIMetadata
    
    // 服务配置
    BindAddr string `json:"bindAddr,omitempty"`
    BindPort int    `json:"bindPort,omitempty"`
    
    // 数据库配置
    Database DatabaseConfig `json:"database,omitempty"`
    
    // 日志配置
    Log LogConfig `json:"log,omitempty"`
    
    // 认证配置
    Auth AuthConfig `json:"auth,omitempty"`
    
    // API 服务器配置
    APIServer APIServerConfig `json:"apiServer,omitempty"`
}

// pkg/config/v1/agent.go
type AgentConfig struct {
    APIMetadata
    
    // 节点信息
    NodeID   string `json:"nodeId,omitempty"`
    NodeName string `json:"nodeName,omitempty"`
    
    // API 服务器连接
    APIServer APIServerConnection `json:"apiServer,omitempty"`
    
    // 监控配置
    Monitor MonitorConfig `json:"monitor,omitempty"`
    
    // sing-box 配置
    SingBox SingBoxConfig `json:"singBox,omitempty"`
    
    // 日志配置
    Log LogConfig `json:"log,omitempty"`
}
```

#### **2. 配置验证与默认值**
```go
// pkg/config/validation/web.go
func ValidateWebConfig(cfg *v1.WebConfig) error {
    if cfg.BindPort <= 0 || cfg.BindPort > 65535 {
        return fmt.Errorf("invalid bind port: %d", cfg.BindPort)
    }
    // 更多验证逻辑...
    return nil
}

// pkg/config/v1/web.go
func (c *WebConfig) SetDefaults() {
    if c.BindAddr == "" {
        c.BindAddr = "0.0.0.0"
    }
    if c.BindPort == 0 {
        c.BindPort = 8080
    }
    // 设置更多默认值...
}
```

---

### **五、服务生命周期管理（参考 Karmada-Manager 设计）**

#### **1. 优雅启动与关闭**
```go
// pkg/server/web/server.go
func (s *WebServer) Start(ctx context.Context) error {
    ctx, cancel := context.WithCancel(ctx)
    s.cancel = cancel
    
    // 初始化组件
    if err := s.initComponents(); err != nil {
        return fmt.Errorf("failed to init components: %w", err)
    }
    
    // 启动 HTTP 服务器
    go s.startHTTPServer(ctx)
    
    // 启动健康检查
    go s.startHealthChecker(ctx)
    
    // 监听关闭信号
    return s.waitForShutdown(ctx)
}

func (s *WebServer) waitForShutdown(ctx context.Context) error {
    signalChan := make(chan os.Signal, 1)
    signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)
    
    select {
    case <-signalChan:
        s.logger.Info("Received shutdown signal")
    case <-ctx.Done():
        s.logger.Info("Context cancelled")
    }
    
    return s.gracefulShutdown()
}
```

#### **2. 健康检查与服务发现**
```go
// pkg/server/common/health.go
type HealthChecker struct {
    checks map[string]HealthCheck
    logger *zap.Logger
}

type HealthCheck interface {
    Check(ctx context.Context) error
}

func (h *HealthChecker) RegisterCheck(name string, check HealthCheck) {
    h.checks[name] = check
}

func (h *HealthChecker) CheckAll(ctx context.Context) map[string]error {
    results := make(map[string]error)
    for name, check := range h.checks {
        results[name] = check.Check(ctx)
    }
    return results
}
```

---

### **六、用户流量与套餐管理**

#### **1. 数据模型设计（优化版）**
```go
// pkg/models/subscription.go
type Plan struct {
    ID               uint64    `gorm:"primaryKey" json:"id"`
    Name             string    `gorm:"not null" json:"name"`
    TrafficLimitGB   int64     `gorm:"not null" json:"trafficLimitGB"`
    DurationDays     int       `gorm:"not null" json:"durationDays"`
    Price            decimal.Decimal `gorm:"type:decimal(10,2)" json:"price"`
    MaxDevices       int       `gorm:"default:3" json:"maxDevices"`
    SpeedLimitMbps   int       `gorm:"default:0" json:"speedLimitMbps"` // 0 表示不限速
    AllowedNodes     []string  `gorm:"type:json" json:"allowedNodes"`
    Features         []string  `gorm:"type:json" json:"features"`
    IsEnabled        bool      `gorm:"default:true" json:"isEnabled"`
    CreatedAt        time.Time `json:"createdAt"`
    UpdatedAt        time.Time `json:"updatedAt"`
}

type Subscription struct {
    ID                uint64          `gorm:"primaryKey" json:"id"`
    UserID            uint64          `gorm:"not null;index" json:"userId"`
    PlanID            uint64          `gorm:"not null;index" json:"planId"`
    Plan              Plan            `gorm:"foreignKey:PlanID" json:"plan"`
    StartTime         time.Time       `gorm:"not null" json:"startTime"`
    EndTime           time.Time       `gorm:"not null" json:"endTime"`
    TrafficUsedBytes  int64           `gorm:"default:0" json:"trafficUsedBytes"`
    TrafficTotalBytes int64           `gorm:"not null" json:"trafficTotalBytes"`
    Status            SubscriptionStatus `gorm:"type:varchar(20);default:'active'" json:"status"`
    AssignedNodes     []string        `gorm:"type:json" json:"assignedNodes"`
    DeviceLimit       int             `gorm:"default:3" json:"deviceLimit"`
    CreatedAt         time.Time       `json:"createdAt"`
    UpdatedAt         time.Time       `json:"updatedAt"`
}

type SubscriptionStatus string

const (
    StatusActive    SubscriptionStatus = "active"
    StatusExpired   SubscriptionStatus = "expired"
    StatusSuspended SubscriptionStatus = "suspended"
    StatusCancelled SubscriptionStatus = "cancelled"
)
```

#### **2. 业务服务层设计**
```go
// pkg/server/web/services/subscription.go
type SubscriptionService interface {
    CreateSubscription(ctx context.Context, req *CreateSubscriptionRequest) (*Subscription, error)
    UpdateTraffic(ctx context.Context, userID uint64, usedBytes int64) error
    CheckAndUpdateStatus(ctx context.Context) error
    GetUserSubscription(ctx context.Context, userID uint64) (*Subscription, error)
}

type subscriptionService struct {
    db     *gorm.DB
    logger *zap.Logger
    apiClient client.APIClient
}

func (s *subscriptionService) CheckAndUpdateStatus(ctx context.Context) error {
    // 检查流量超限
    expiredSubs, err := s.findExpiredSubscriptions(ctx)
    if err != nil {
        return err
    }
    
    // 批量更新状态
    for _, sub := range expiredSubs {
        if err := s.suspendUser(ctx, sub.UserID); err != nil {
            s.logger.Error("Failed to suspend user", zap.Uint64("userID", sub.UserID), zap.Error(err))
        }
    }
    
    return nil
}
```

---

### **七、SkyWalking 统一无侵入集成（优化版）**

#### **1. Agent 配置管理**

SkyWalking 是一个开源的分布式链路追踪系统，可以用于监控和分析分布式系统的性能和可用性。

通过 agent 模式在编译应用时集成，可实现无侵入式链路追踪集成。https://skywalking.apache.org/docs/skywalking-go/next/en/agent/support-plugins/

### **八、监控与告警设计**

#### **1. 指标定义**
```go
// pkg/metrics/metrics.go
var (
    // HTTP 指标
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "sing_box_web_http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "path", "status"},
    )
    
    // 节点指标
    nodeStatus = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "sing_box_node_status",
            Help: "Node status (1=online, 0=offline)",
        },
        []string{"node_id", "node_name"},
    )
    
    // 用户指标
    userTrafficBytes = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "sing_box_user_traffic_bytes_total",
            Help: "Total user traffic in bytes",
        },
        []string{"user_id", "direction"},
    )
)
```

#### **2. 告警规则**
```yaml
# deploy/monitoring/alerts.yaml
groups:
  - name: sing-box-platform
    rules:
      - alert: NodeOffline
        expr: sing_box_node_status == 0
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "节点 {{ $labels.node_name }} 离线"
          description: "节点 {{ $labels.node_name }} ({{ $labels.node_id }}) 已离线超过 5 分钟"
          
      - alert: HighCPUUsage
        expr: node_cpu_usage_percent > 80
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "节点 {{ $labels.node_name }} CPU 使用率过高"
          description: "节点 {{ $labels.node_name }} CPU 使用率已超过 80% 持续 10 分钟"
```

---

### **九、部署与运维**

#### **1. 容器化部署**
```dockerfile
# build/web/Dockerfile
FROM golang:1.23-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o sing-box-web cmd/web/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/
COPY --from=builder /app/sing-box-web .
COPY --from=builder /app/web/dist ./web/
EXPOSE 8080
CMD ["./sing-box-web"]
```

#### **2. 部署配置**
```yaml
# deploy/k8s/web-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sing-box-web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: sing-box-web
  template:
    metadata:
      labels:
        app: sing-box-web
    spec:
      containers:
      - name: web
        image: sing-box-web:latest
        ports:
        - containerPort: 8080
        env:
        - name: CONFIG_PATH
          value: "/etc/sing-box/web.yaml"
        volumeMounts:
        - name: config
          mountPath: /etc/sing-box
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
```

---

### **十、总结与最佳实践**

基于 Karmada-Manager 和 frp 的架构分析，本设计采用了以下最佳实践：

1. **清晰的项目结构**：cmd/pkg 分离，版本化配置管理
2. **优雅的服务生命周期**：统一的启动/关闭机制，健康检查
3. **模块化设计**：可插拔的组件，接口驱动开发
4. **配置管理**：版本化配置，验证与默认值处理
5. **可观测性**：全链路追踪，结构化日志，丰富指标
6. **容器化部署**：标准化部署流程，资源限制

这种架构设计确保了系统的**可维护性**、**可扩展性**和**生产就绪性**，同时在低配置环境下保持良好的性能表现。
